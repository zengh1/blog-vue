---
title: c++ 引用：如何理解"引用被初始化后，不能再指向其他对象"
date: 2020-01-11
tags: 
  - c++
author: Billyyyyy3320
location: Taipei  
---



在 c++ 的引用规则中，有这么一条：**一旦初始化完成 ，引用将和它的初始值对象一直绑定在一起（即不能再指向其他对象）**。抱着初学者的好奇心态，我尝试改变引用的指向，写出了如下代码：

```c++
// 定义两个 string 变量
std::string s = "123";
std::string s2 = "456";

// 让 s1 引用 s
std::string &s1 = s;
std::cout << "修改前：" << "s1: " << s1 << std::endl;
// 修改 s1 的引用？
s1 = s2;  
std::cout << "修改后：" << "s1: " << s1 << std::endl;

// output
修改前：s1: 123
修改后：s1: 456

```



这里我让 s1 重新指向 s2，并且从输出结果来看，s1 的值也确实被修改了，不对啊，规则中明明说好了不能修改的，怎么实际代码中可以？为了验证引用是否真的被修改，将三个变量的指针打印出来：

```c++
printf("指针 => s1: %p | s2: %p | s: %p \n", &s1, &s2, &s);

// output
指针 => s1: 0x7ffee199e7c8 | s2: 0x7ffee199e7b0 | s: 0x7ffee199e7c8 
```

s1 和 s3 是同一个地址，说明引用并未改变，所以并不是引用被修改了，而是我的理解出现了问题，代码中的 s1 = s2，并不是让引用重新指向 s2，而是把值赋给了与引用绑定的对象（等同于 s = s2），这里做一个简单验证就很好理解了：

```c++
// 定义两个 string 变量
std::string s = "123";
std::string s2 = "456";

// 让 s1 引用 s
std::string &s1 = s;
std::cout << "修改前：" << "s1: " << s1 << std::endl;
// 修改 s1 的引用？
s1 = s2;  
// 修改 s2 的值，如果 s1 的引用被修改为指向 s2，那么 s1 的值应该也会改为 "666"
s2 = "666";
std::cout << "修改后：" << "s1: " << s1 << std::endl;


// output
修改前：s1: 123
修改后：s1: 456
```

s1 并没有被修改为 "666"，所以可以印证上面的说法。

<Vssue :title="$title" />








